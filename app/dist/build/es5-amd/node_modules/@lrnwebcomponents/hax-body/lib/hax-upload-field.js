define(["exports","../../../lit-element/lit-element.js","../../simple-fields/lib/simple-fields-upload.js","../../utils/utils.js"],function(_exports,_litElement,_simpleFieldsUpload,_utils){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HaxUploadField=void 0;var HaxUploadField=/*#__PURE__*/function(_winEventsElement){babelHelpers.inherits(HaxUploadField,_winEventsElement);/**
   * HTMLElement life cycle
   */function HaxUploadField(){var _this;babelHelpers.classCallCheck(this,HaxUploadField);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HaxUploadField).call(this));_this.__winEvents={"hax-app-picker-selection":"_haxAppPickerSelection"};return _this}/**
   * Respond to uploading a file
   */babelHelpers.createClass(HaxUploadField,[{key:"_fileAboutToUpload",value:function _fileAboutToUpload(e){if(!this.__allowUpload&&window.HaxStore){// cancel the event so we can jump in
e.preventDefault();e.stopPropagation();// look for a match as to what gizmo types it supports
var values={source:e.detail.file.name,type:e.detail.file.type},type=window.HaxStore.guessGizmoType(values),targets=window.HaxStore.getHaxAppStoreTargets(type);// we have no clue what this is.. let's try and guess..
// make sure we have targets
if(1===targets.length){this._haxAppPickerSelection({detail:targets[0]})}else if(0!==targets.length){window.HaxStore.instance.haxAppPicker.presentOptions(targets,type,"Where would you like to upload this "+type+"?","app")}else{window.HaxStore.toast("Sorry, you don't have a storage location that can handle "+type+" uploads!",5e3)}}else{this.__allowUpload=!1}}/**
   * Respond to successful file upload, now inject url into url field and
   * do a gizmo guess from there!
   */},{key:"_fileUploadResponse",value:function _fileUploadResponse(e){// convert response to object
var response=JSON.parse(e.detail.xhr.response),map=this.__appUsed.connection.operations.add.resultMap,data={},item={};// access the app that did the upload
// look for the items element to draw our data from at its root
if(babelHelpers.typeof(this._resolveObjectPath(map.item,response))!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){data=this._resolveObjectPath(map.item,response)}item.type=map.defaultGizmoType;// pull in prop matches
for(var prop in map.gizmo){item[prop]=this._resolveObjectPath(map.gizmo[prop],data)}// another sanity check, if we don't have a url but have a source bind that too
if(babelHelpers.typeof(item.url)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(item.source)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){item.url=item.source}// gizmo type is also supported in the mapping element itself
// Think an asset management backend as opposed to a specific
// type of asset like video. If the item coming across can
// effectively check what kind of gizmo is required for it
// to work then we need to support that asset declaring the
// gizmo type needed
if(babelHelpers.typeof(map.gizmo.type)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){item.type=this._resolveObjectPath(map.gizmo.type,data)}// set the value of the url which will update our URL and notify
this.shadowRoot.querySelector("#url").value=item.url}/**
   * Event for an app being selected from a picker
   * This happens when multiple upload targets support the given type
   */},{key:"_haxAppPickerSelection",value:function _haxAppPickerSelection(e){// details for where to upload the file
var connection=e.detail.connection;this.__appUsed=e.detail;this.shadowRoot.querySelector("#fileupload").method=connection.operations.add.method;var requestEndPoint=connection.protocol+"://"+connection.url;// ensure we build a url correctly
if("/"!=requestEndPoint.substr(requestEndPoint.length-1)){requestEndPoint+="/"}// support local end point modification
if(babelHelpers.typeof(connection.operations.add.endPoint)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){requestEndPoint+=connection.operations.add.endPoint}// implementation specific tweaks to talk to things like HAXcms and other CMSs
// that have per load token based authentication
if(null!=window.HaxStore.instance.connectionRewrites.appendUploadEndPoint){requestEndPoint+="?"+window.HaxStore.instance.connectionRewrites.appendUploadEndPoint}if(null!=window.HaxStore.instance.connectionRewrites.appendJwt){requestEndPoint+="&"+window.HaxStore.instance.connectionRewrites.appendJwt+"="+localStorage.getItem(window.HaxStore.instance.connectionRewrites.appendJwt)}this.shadowRoot.querySelector("#fileupload").headers=connection.headers;this.shadowRoot.querySelector("#fileupload").target=requestEndPoint;// invoke file uploading...
this.__allowUpload=!0;this.shadowRoot.querySelector("#fileupload").uploadFiles()}}]);return HaxUploadField}((0,_utils.winEventsElement)(_simpleFieldsUpload.SimpleFieldsUpload));_exports.HaxUploadField=HaxUploadField;window.customElements.define("hax-upload-field",HaxUploadField)});