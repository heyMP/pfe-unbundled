define(["exports"],function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.default=void 0;function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1,source;i<arguments.length;i++){source=null!=arguments[i]?arguments[i]:{};if(i%2){ownKeys(Object(source),!0).forEach(function(key){babelHelpers.defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}function _createForOfIteratorHelper(o,allowArrayLike){var it;if("undefined"===typeof Symbol||null==o[Symbol.iterator]){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&"number"===typeof o.length){if(it)o=it;var i=0,F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:!0};return{done:!1,value:o[i++]}},e:function e(_e){throw _e},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var normalCompletion=!0,didErr=!1,err;return{s:function s(){it=o[Symbol.iterator]()},n:function n(){var step=it.next();normalCompletion=step.done;return step},e:function e(_e2){didErr=!0;err=_e2},f:function f(){try{if(!normalCompletion&&null!=it.return)it.return()}finally{if(didErr)throw err}}}}function _unsupportedIterableToArray(o,minLen){if(!o)return;if("string"===typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if("Object"===n&&o.constructor)n=o.constructor.name;if("Map"===n||"Set"===n)return Array.from(o);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}function _arrayLikeToArray(arr,len){if(null==len||len>arr.length)len=arr.length;for(var i=0,arr2=Array(len);i<len;i++){arr2[i]=arr[i]}return arr2}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=babelHelpers.getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=babelHelpers.getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget)}else{result=Super.apply(this,arguments)}return babelHelpers.possibleConstructorReturn(this,result)}}function _isNativeReflectConstruct(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{Date.prototype.toString.call(Reflect.construct(Date,[],function(){}));return!0}catch(e){return!1}}var logger=function logger(){return null};function reveal(){logger("[reveal] elements ready, revealing the body");window.document.body.removeAttribute("unresolved")}function autoReveal(logFunction){logger=logFunction;// If Web Components are already ready, run the handler right away.  If they
// are not yet ready, wait.
//
// see https://github.com/github/webcomponentsjs#webcomponents-loaderjs for
// info about web component readiness events
var polyfillPresent=window.WebComponents,polyfillReady=polyfillPresent&&window.WebComponents.ready;if(!polyfillPresent||polyfillReady){handleWebComponentsReady()}else{window.addEventListener("WebComponentsReady",handleWebComponentsReady)}}function handleWebComponentsReady(){logger("[reveal] web components ready");reveal()}/**
 * Verify that a property definition's `type` field contains one of the allowed
 * types.
 *
 * Allowed types are String, Number, and Boolean.  If `type` is falsy, it
 * defaults to String.
 */function isAllowedType(definition){return[String,Number,Boolean].includes(definition.type||String)}/**
 * Verify that a property definition's `default` value is of the correct type.
 *
 * A `default` value is valid if it's of the same type as the `type`
 * definition.  Or, if there is no `type` definition, then it must be a String
 * (the default value for `type`).
 */function isValidDefaultType(definition){return definition.hasOwnProperty("default")&&definition.default.constructor===definition.type}// @POLYFILL  Array.includes
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
if(!Array.prototype.includes){Object.defineProperty(Array.prototype,"includes",{value:function value(valueToFind,fromIndex){if(null==this){throw new TypeError("\"this\" is null or not defined")}// 1. Let O be ? ToObject(this value).
var o=Object(this),len=o.length>>>0;// 2. Let len be ? ToLength(? Get(O, "length")).
// 3. If len is 0, return false.
if(0===len){return!1}// 4. Let n be ? ToInteger(fromIndex).
//    (If fromIndex is undefined, this step produces the value 0.)
var n=0|fromIndex,k=Math.max(0<=n?n:len-Math.abs(n),0);// 5. If n â‰¥ 0, then
//  a. Let k be n.
// 6. Else n < 0,
//  a. Let k be len + n.
//  b. If k < 0, let k be 0.
function sameValueZero(x,y){return x===y||"number"===typeof x&&"number"===typeof y&&isNaN(x)&&isNaN(y)}// 7. Repeat, while k < len
while(k<len){// a. Let elementK be the result of ? Get(O, ! ToString(k)).
// b. If SameValueZero(valueToFind, elementK) is true, return true.
if(sameValueZero(o[k],valueToFind)){return!0}// c. Increase k by 1.
k++}// 8. Return false
return!1}})}// @POLYFILL Object.entries
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries
if(!Object.entries){Object.entries=function(obj){var ownProps=Object.keys(obj),i=ownProps.length,resArray=Array(i);// preallocate the Array
while(i--){resArray[i]=[ownProps[i],obj[ownProps[i]]]}return resArray}}/*!
 * PatternFly Elements: PFElement 1.0.0
 * @license
 * Copyright 2020 Red Hat, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
*/var prefix="pfe",PFElement=/*#__PURE__*/function(_HTMLElement){babelHelpers.inherits(PFElement,_HTMLElement);var _super=_createSuper(PFElement);babelHelpers.createClass(PFElement,[{key:"log",/**
   * Local logging that outputs the tag name as a prefix automatically
   *
   * @example In a component's function: `this.log("Hello")`
   */value:function log(){for(var _len=arguments.length,msgs=Array(_len),_key=0;_key<_len;_key++){msgs[_key]=arguments[_key]}PFElement.log("[".concat(this.tag).concat(this.id?"#".concat(this.id):"","]: ").concat(msgs.join(", ")))}/**
   * A console warning wrapper which formats your output with useful debugging information.
   *
   * @example `PFElement.warn("Hello")`
   */},{key:"warn",/**
   * Local warning wrapper that outputs the tag name as a prefix automatically.
   *
   * @example In a component's function: `this.warn("Hello")`
   */value:function warn(){for(var _len2=arguments.length,msgs=Array(_len2),_key2=0;_key2<_len2;_key2++){msgs[_key2]=arguments[_key2]}PFElement.warn("[".concat(this.tag).concat(this.id?"#".concat(this.id):"","]: ").concat(msgs.join(", ")))}/**
   * A console error wrapper which formats your output with useful debugging information.
   *
   * @example `PFElement.error("Hello")`
   */},{key:"error",/**
   * Local error wrapper that outputs the tag name as a prefix automatically.
   *
   * @example In a component's function: `this.error("Hello")`
   */value:function error(){for(var _len3=arguments.length,msgs=Array(_len3),_key3=0;_key3<_len3;_key3++){msgs[_key3]=arguments[_key3]}PFElement.error.apply(PFElement,["[".concat(this.tag).concat(this.id?"#".concat(this.id):"","]:")].concat(msgs))}/**
   * A global definition of component types (a general way of defining the purpose of a
   * component and how it is put together).
   */},{key:"hasLightDOM",/**
   * Returns a boolean statement of whether or not this component contains any light DOM.
   *
   * @example: `this.hasLightDOM()`
   */value:function hasLightDOM(){return this.children.length||this.textContent.trim().length}/**
   * Returns a boolean statement of whether or not that slot exists in the light DOM.
   *
   * @example: `this.hasSlot("header")`
   */},{key:"hasSlot",value:function hasSlot(name){var _this2=this;if(!name){this.warn("Please provide at least one slot name for which to search.");return}switch(babelHelpers.typeof(name)){case"string":return 0<babelHelpers.toConsumableArray(this.children).filter(function(child){return child.hasAttribute("slot")&&child.getAttribute("slot")===name}).length;case"array":return name.reduce(function(n){return 0<babelHelpers.toConsumableArray(_this2.children).filter(function(child){return child.hasAttribute("slot")&&child.getAttribute("slot")===n}).length});default:this.warn("Did not recognize the type of the name provided to hasSlot; this funciton can accept a string or an array.");return;}}/**
   * Returns an array with all the slot with the provided name defined in the light DOM.
   * If no value is provided (i.e., `this.getSlot()`), it returns all unassigned slots.
   *
   * @example: `this.hasSlot("header")`
   */},{key:"getSlot",value:function getSlot(){var name=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"unassigned";if("unassigned"!==name){return babelHelpers.toConsumableArray(this.children).filter(function(child){return child.hasAttribute("slot")&&child.getAttribute("slot")===name})}else{return babelHelpers.toConsumableArray(this.children).filter(function(child){return!child.hasAttribute("slot")})}}},{key:"cssVariable",value:function cssVariable(name,value){var element=2<arguments.length&&arguments[2]!==void 0?arguments[2]:this;name="--"!==name.substr(0,2)?"--"+name:name;if(value){element.style.setProperty(name,value);return value}return window.getComputedStyle(element).getPropertyValue(name).trim()||null}/**
   * This alerts nested components to a change in the context
   */},{key:"contextUpdate",value:function contextUpdate(){var _this3=this;// If a value has been set, alert any nested children of the change
[].concat(babelHelpers.toConsumableArray(this.querySelectorAll("*")),babelHelpers.toConsumableArray(this.shadowRoot.querySelectorAll("*"))).filter(function(item){return item.tagName.toLowerCase().slice(0,4)==="".concat(prefix,"-")}).map(function(child){_this3.log("Update context of ".concat(child.tag));Promise.all([customElements.whenDefined(child.tagName.toLowerCase())]).then(function(){// Ask the component to recheck it's context in case it changed
child.resetContext(_this3.on)})})}},{key:"resetContext",value:function resetContext(fallback){this.log("Resetting context on ".concat(this.tag));// Priority order for context values to be pulled from:
//--> 1. context (OLD: pfe-theme)
//--> 2. --context (OLD: --theme)
var value=this.context||this.contextVariable||fallback;this.on=value}},{key:"version",/**
   * A local alias to the static version.
   *
   * @example: In the console: `PfeAccordion.version`
   */get:function get(){return this._pfeClass.version}/**
   * Global property definitions: properties managed by the base class that apply to all components.
   */},{key:"randomId",/**
   * A quick way to fetch a random ID value.
   * _Note:_ All values are prefixes with `pfe` automatically to ensure an ID-safe value is returned.
   *
   * @example: In a component's JS: `this.id = this.randomID;`
   */get:function get(){return"".concat(prefix,"-")+Math.random().toString(36).substr(2,9)}/**
   * Set the --context variable with the provided value in this component.
   */},{key:"contextVariable",set:function set(value){this.cssVariable("context",value)}/**
   * Get the current value of the --context variable in this component.
   */,get:function get(){// @TODO: Deprecated theme in 1.0
return this.cssVariable("context")||this.cssVariable("theme")}}],[{key:"debugLog",/**
   * A boolean value that indicates if the logging should be printed to the console; used for debugging.
   *
   * @example In a JS file or script tag: `PFElement._debugLog = true;`
   */value:function debugLog(){var preference=0<arguments.length&&arguments[0]!==void 0?arguments[0]:null;if(null!==preference){PFElement._debugLog=!!preference}return PFElement._debugLog}/**
   * A logging wrapper which checks the debugLog boolean and prints to the console if true.
   *
   * @example `PFElement.log("Hello")`
   */},{key:"log",value:function log(){if(PFElement.debugLog()){var _console;(_console=console).log.apply(_console,arguments)}}},{key:"warn",value:function warn(){var _console2;(_console2=console).warn.apply(_console2,arguments)}},{key:"error",value:function error(){for(var _len4=arguments.length,msgs=Array(_len4),_key4=0;_key4<_len4;_key4++){msgs[_key4]=arguments[_key4]}throw new Error([].concat(msgs).join(" "))}},{key:"PfeTypes",get:function get(){return{Container:"container",Content:"content",Combo:"combo"}}/**
   * The current version of a component; set by the compiler using the package.json data.
   */},{key:"version",get:function get(){return"{{version}}"}},{key:"properties",get:function get(){return{pfelement:{title:"Upgraded flag",type:Boolean,default:!0,observer:"_upgradeObserver"},on:{title:"Context",description:"Describes the visual context (backgrounds).",type:String,values:["light","dark","saturated"],default:function _default(el){return el.contextVariable},observer:"_onObserver"},context:{title:"Context hook",description:"Lets you override the system-set context.",type:String,values:["light","dark","saturated"],observer:"_contextObserver"},// @TODO: Deprecated with 1.0
oldTheme:{type:String,values:["light","dark","saturated"],alias:"context",attr:"pfe-theme"},_style:{title:"Custom styles",type:String,attr:"style",observer:"_inlineStyleObserver"},type:{title:"Component type",type:String,values:["container","content","combo"]}}}},{key:"observedAttributes",get:function get(){var _this4=this,properties=this.allProperties;if(properties){var oa=Object.keys(properties).filter(function(prop){return properties[prop].observer||properties[prop].cascade||properties[prop].alias}).map(function(p){return _this4._convertPropNameToAttrName(p)});return babelHelpers.toConsumableArray(oa)}}}]);function PFElement(pfeClass){var _this,_ref=1<arguments.length&&arguments[1]!==void 0?arguments[1]:{},_ref$type=_ref.type,type=void 0===_ref$type?null:_ref$type,_ref$delayRender=_ref.delayRender,delayRender=void 0===_ref$delayRender?!1:_ref$delayRender;babelHelpers.classCallCheck(this,PFElement);_this=_super.call(this);_this._pfeClass=pfeClass;_this.tag=pfeClass.tag;_this._parseObserver=_this._parseObserver.bind(babelHelpers.assertThisInitialized(_this));// TODO: Deprecated for 1.0 release
_this.schemaProps=pfeClass.schemaProperties;// TODO: Migrate this out of schema for 1.0
_this.slots=pfeClass.slots;_this.template=document.createElement("template");// Set the default value to the passed in type
if(type&&_this._pfeClass.allProperties.type)_this._pfeClass.allProperties.type.default=type;// Initalize the properties and attributes from the property getter
_this._initializeProperties();_this.attachShadow({mode:"open"});if(!delayRender)_this.render();return _this}/**
   * Standard connected callback; fires when the component is added to the DOM.
   */babelHelpers.createClass(PFElement,[{key:"connectedCallback",value:function connectedCallback(){var _this5=this;this._initializeAttributeDefaults();if(window.ShadyCSS)window.ShadyCSS.styleElement(this);// If the slot definition exists, set up an observer
if("object"===babelHelpers.typeof(this.slots)){this._slotsObserver=new MutationObserver(function(){return _this5._initializeSlots(_this5.tag,_this5.slots)});this._slotsObserver.observe(this,{childList:!0});this._initializeSlots(this.tag,this.slots)}// If an observer was defined, set it to begin observing here
if(this._cascadeObserver)this._cascadeObserver.observe(this,{attributes:!0,childList:!0,subtree:!0})}/**
   * Standard disconnected callback; fires when a componet is removed from the DOM.
   * Add your removeEventListeners here.
   */},{key:"disconnectedCallback",value:function disconnectedCallback(){if(this._cascadeObserver)this._cascadeObserver.disconnect();if(this._slotsObserver)this._slotsObserver.disconnect()}/**
   * Attribute changed callback fires when attributes are updated.
   * This combines the global and the component-specific logic.
   */},{key:"attributeChangedCallback",value:function attributeChangedCallback(attr,oldVal,newVal){if(!this._pfeClass.allProperties)return;var propName=this._pfeClass._attr2prop(attr),propDef=this._pfeClass.allProperties[propName];// If the attribute that changed derives from a property definition
if(propDef){// If the property/attribute pair has an alias, copy the new value to the alias target
if(propDef.alias){var aliasedPropDef=this._pfeClass.allProperties[propDef.alias],aliasedAttr=this._pfeClass._prop2attr(propDef.alias),aliasedAttrVal=this.getAttribute(aliasedAttr);if(aliasedAttrVal!==newVal){this[propDef.alias]=this._castPropertyValue(aliasedPropDef,newVal)}}// If the property/attribute pair has an observer, fire it
// Observers receive the oldValue and the newValue from the attribute changed callback
if(propDef.observer){this[propDef.observer](this._castPropertyValue(propDef,oldVal),this._castPropertyValue(propDef,newVal))}// If the property/attribute pair has a cascade target, copy the attribute to the matching elements
if(propDef.cascade){this._copyAttribute(attr,this._pfeClass._convertSelectorsToArray(propDef.cascade))}}}/**
   * Standard render function.
   */},{key:"render",value:function render(){this.shadowRoot.innerHTML="";this.template.innerHTML=this.html;if(window.ShadyCSS){window.ShadyCSS.prepareTemplate(this.template,this.tag)}this.shadowRoot.appendChild(this.template.content.cloneNode(!0));this.log("render");this.resetContext()}/**
   * A wrapper around an event dispatch to standardize formatting.
   */},{key:"emitEvent",value:function emitEvent(name){var _ref2=1<arguments.length&&arguments[1]!==void 0?arguments[1]:{},_ref2$bubbles=_ref2.bubbles,bubbles=void 0===_ref2$bubbles?!0:_ref2$bubbles,_ref2$cancelable=_ref2.cancelable,cancelable=void 0===_ref2$cancelable?!1:_ref2$cancelable,_ref2$composed=_ref2.composed,composed=void 0===_ref2$composed?!1:_ref2$composed,_ref2$detail=_ref2.detail,detail=void 0===_ref2$detail?{}:_ref2$detail;this.log("Custom event: ".concat(name));this.dispatchEvent(new CustomEvent(name,{bubbles:bubbles,cancelable:cancelable,composed:composed,detail:detail}))}/**
   * Handles the cascading of properties to nested components
   */},{key:"cascadeProperties",value:function cascadeProperties(nodeList){var _this6=this,cascade=this._pfeClass._getCache("cascadingProperties");if(cascade){if(window.ShadyCSS&&this._cascadeObserver)this._cascadeObserver.disconnect();var selectors=Object.keys(cascade);// Find out if anything in the nodeList matches any of the observed selectors for cacading properties
if(nodeList){selectors=[];babelHelpers.toConsumableArray(nodeList).forEach(function(nodeItem){Object.keys(cascade).map(function(selector){// if this node has a match function (i.e., it's an HTMLElement, not
// a text node), see if it matches the selector, otherwise drop it (like it's hot).
if(nodeItem.matches&&nodeItem.matches(selector)){selectors.push(selector)}})})}// If a match was found, cascade each attribute to the element
if(selectors){var components=selectors.filter(function(item){return item.slice(0,prefix.length+1)==="".concat(prefix,"-")}).map(function(name){return customElements.whenDefined(name)});if(components)Promise.all(components).then(function(){_this6._copyAttributes(selectors,cascade)});else this._copyAttributes(selectors,cascade)}if(window.ShadyCSS&&this._cascadeObserver)this._cascadeObserver.observe(this,{attributes:!0,childList:!0,subtree:!0})}}/* --- Observers for global properties --- */ /**
   * This responds to changes in the pfelement attribute; indicates if the component upgraded
   * @TODO maybe we should use just the attribute instead of the class?
   * https://github.com/angular/angular/issues/15399#issuecomment-318785677
   */},{key:"_upgradeObserver",value:function _upgradeObserver(){this.classList.add("PFElement")}/**
   * This responds to changes in the context attribute; manual override tool
   */},{key:"_contextObserver",value:function _contextObserver(oldValue,newValue){if(newValue&&(oldValue&&oldValue!==newValue||!oldValue)){this.on=newValue;this.cssVariable("context",newValue)}}/**
   * This responds to changes in the context; source of truth for components
   */},{key:"_onObserver",value:function _onObserver(oldValue,newValue){if(oldValue&&oldValue!==newValue||newValue&&!oldValue){// Fire an event for child components
this.contextUpdate()}}/**
   * This responds to inline style changes and greps for context or theme updates.
   * @TODO: --theme will be deprecated in 2.0
   */},{key:"_inlineStyleObserver",value:function _inlineStyleObserver(oldValue,newValue){this.log("Style observer activated on ".concat(this.tag));var newContext="",regex=/--(?:context|theme):\s*(?:\"*(light|dark|saturated)\"*)/gi,found=regex.exec(newValue);// Grep for context/theme
if(found){newContext=found[1];// If the new context value differs from the on value, update
if(newContext!==this.on&&!this.context)this.on=newContext}}/**
   * This is connected with a mutation observer that watches for updates to the light DOM
   * and pushes down the cascading values
   */},{key:"_parseObserver",value:function _parseObserver(mutationsList){// Iterate over the mutation list, look for cascade updates
var _iterator=_createForOfIteratorHelper(mutationsList),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var mutation=_step.value;// If a new node is added, attempt to cascade attributes to it
if("childList"===mutation.type&&mutation.addedNodes.length){this.cascadeProperties(mutation.addedNodes)}}}catch(err){_iterator.e(err)}finally{_iterator.f()}}/* --- End observers --- */ /**
   * Validate that the property meets the requirements for type and naming.
   */},{key:"_castPropertyValue",/**
   * Convert provided property value to the correct type as defined in the properties method.
   */value:function _castPropertyValue(propDef,attrValue){var _attrValue$null$NaN$u,_attrValue$undefined$;switch(propDef.type){case Number:// map various attribute string values to their respective
// desired property values
return(_attrValue$null$NaN$u={},babelHelpers.defineProperty(_attrValue$null$NaN$u,attrValue,+attrValue),babelHelpers.defineProperty(_attrValue$null$NaN$u,"null",null),babelHelpers.defineProperty(_attrValue$null$NaN$u,"NaN",NaN),babelHelpers.defineProperty(_attrValue$null$NaN$u,"undefined",void 0),_attrValue$null$NaN$u)[attrValue];case Boolean:return null!==attrValue;case String:return(_attrValue$undefined$={},babelHelpers.defineProperty(_attrValue$undefined$,attrValue,attrValue),babelHelpers.defineProperty(_attrValue$undefined$,"undefined",void 0),_attrValue$undefined$)[attrValue];default:return attrValue;}}/**
   * Map provided value to the attribute name on the component.
   */},{key:"_assignValueToAttribute",value:function _assignValueToAttribute(obj,attr,value){// If the default is false and the property is boolean, we don't need to do anything
var isBooleanFalse=obj.type===Boolean&&!value,isNull=null===value,isUndefined="undefined"===typeof value;// If the attribute is not defined, set the default value
if(isBooleanFalse||isNull||isUndefined){this.removeAttribute(attr)}else{// Boolean values get an empty string: https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes
if(obj.type===Boolean&&"boolean"===typeof value){this.setAttribute(attr,"")}else{// Validate against the provided values
if(obj.values){this._validateAttributeValue(obj,attr,value)}// Still accept the value provided even if it's not valid
this.setAttribute(attr,value)}}}/**
   * Maps the defined slots into an object that is easier to query
   */},{key:"_initializeSlots",value:function _initializeSlots(tag,slots){var _this7=this;this.log("Validate slots...");if(window.ShadyCSS&&this._slotsObserver)this._slotsObserver.disconnect();// Loop over the properties provided by the schema
Object.keys(slots).forEach(function(slot){var slotObj=slots[slot];// Only attach the information if the data provided is a schema object
if("object"===babelHelpers.typeof(slotObj)){var slotExists=!1,result=[];// If it's a named slot, look for that slot definition
if(slotObj.namedSlot){// Check prefixed slots
result=_this7.getSlot("".concat(tag,"--").concat(slot));if(0<result.length){slotObj.nodes=result;slotExists=!0}// Check for unprefixed slots
result=_this7.getSlot("".concat(slot));if(0<result.length){slotObj.nodes=result;slotExists=!0}// If it's the default slot, look for direct children not assigned to a slot
}else{result=babelHelpers.toConsumableArray(_this7.children).filter(function(child){return!child.hasAttribute("slot")});if(0<result.length){slotObj.nodes=result;slotExists=!0}}// If the slot exists, attach an attribute to the parent to indicate that
if(slotExists){_this7.setAttribute("has_".concat(slot),"")}else{_this7.removeAttribute("has_".concat(slot))}}});this.log("Slots validated.");if(window.ShadyCSS&&this._slotsObserver)this._slotsObserver.observe(this,{childList:!0})}/**
   * Sets up the property definitions based on the properties method.
   */},{key:"_initializeProperties",value:function _initializeProperties(){var _this8=this,properties=this._pfeClass.allProperties,hasCascade=!1,_loop=function _loop(propName){var propDef=properties[propName];// Check if the property exists, throw a warning if it does.
// HTMLElements have a LOT of properties; it wouldn't be hard
// to overwrite one accidentally.
if("undefined"!==typeof _this8[propName]){_this8.log("Property \"".concat(propName,"\" on ").concat(_this8.constructor.name," cannot be defined because the property name is reserved"))}else{var attrName=_this8._pfeClass._prop2attr(propName);if(propDef.cascade)hasCascade=!0;Object.defineProperty(_this8,propName,{get:function get(){var attrValue=_this8.getAttribute(attrName);return _this8._castPropertyValue(propDef,attrValue)},set:function set(rawNewVal){// Assign the value to the attribute
_this8._assignValueToAttribute(propDef,attrName,rawNewVal);return rawNewVal},writeable:!0,enumerable:!0,configurable:!1})}};for(var propName in properties){_loop(propName)}// If any of the properties has cascade, attach a new mutation observer to the component
if(hasCascade){this._cascadeObserver=new MutationObserver(this._parseObserver)}}/**
   * Intialize the default value for an attribute.
   */},{key:"_initializeAttributeDefaults",value:function _initializeAttributeDefaults(){var properties=this._pfeClass.allProperties;for(var propName in properties){var propDef=properties[propName],attrName=this._pfeClass._prop2attr(propName);if(propDef.hasOwnProperty("default")){var value=propDef.default;// Check if default is a function
if("function"===typeof propDef.default){value=propDef.default(this)}// If the attribute has not already been set, assign the default value
if(!this.hasAttribute(attrName)){// Assign the value to the attribute
this._assignValueToAttribute(propDef,attrName,value)}}}}/**
   * Validate the value against provided values.
   */ // @TODO add support for a validation function
},{key:"_validateAttributeValue",value:function _validateAttributeValue(propDef,attr,value){if(Array.isArray(propDef.values)&&0<propDef.values.length&&!propDef.values.includes(value)// ||
// (typeof propDef.values === "string" && propDef.values !== value) ||
// (typeof propDef.values === "function" && !propDef.values(value))
){this.warn("".concat(value," is not a valid value for ").concat(attr,". Please provide one of the following values: ").concat(propDef.values.join(", ")))}return value}/**
   * Look up an attribute name linked to a given property name.
   */},{key:"_copyAttributes",value:function _copyAttributes(selectors,set){var _this9=this;selectors.forEach(function(selector){set[selector].forEach(function(attr){_this9._copyAttribute(attr,selector)})})}},{key:"_copyAttribute",value:function _copyAttribute(name,to){var recipients=[].concat(babelHelpers.toConsumableArray(this.querySelectorAll(to)),babelHelpers.toConsumableArray(this.shadowRoot.querySelectorAll(to))),value=this.getAttribute(name),fname=null==value?"removeAttribute":"setAttribute",_iterator2=_createForOfIteratorHelper(recipients),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var node=_step2.value;node[fname](name,value)}}catch(err){_iterator2.e(err)}finally{_iterator2.f()}}}],[{key:"_validateProperties",value:function _validateProperties(){for(var propName in this.allProperties){var propDef=this.allProperties[propName];// Verify that properties conform to the allowed data types
if(!isAllowedType(propDef)){this.error("Property \"".concat(propName,"\" on ").concat(this.name," must have type String, Number, or Boolean."))}// Verify the property name conforms to our naming rules
if(!/^[a-z_]/.test(propName)){this.error("Property ".concat(this.name,".").concat(propName," defined, but prop names must begin with a lower-case letter or an underscore"))}var isFunction="function"===typeof propDef.default;// If the default value is not the same type as defined by the property
// and it's not a function (we can't validate the output of the function
// on the class level), throw a warning
if(propDef.default&&!isValidDefaultType(propDef)&&!isFunction)this.error("[".concat(this.name,"] The default value `").concat(propDef.default,"` does not match the assigned type ").concat(propDef.type.name," for the '").concat(propName,"' property"))}}},{key:"_prop2attr",value:function _prop2attr(propName){return this._getCache("prop2attr")[propName]}/**
   * Look up an property name linked to a given attribute name.
   */},{key:"_attr2prop",value:function _attr2prop(attrName){return this._getCache("attr2prop")[attrName]}/**
   * Convert a property name to an attribute name.
   */},{key:"_convertPropNameToAttrName",value:function _convertPropNameToAttrName(propName){var propDef=this.allProperties[propName];if(propDef.attr){return propDef.attr}return propName.replace(/^_/,"").replace(/^[A-Z]/,function(l){return l.toLowerCase()}).replace(/[A-Z]/g,function(l){return"-".concat(l.toLowerCase())})}/**
   * Convert an attribute name to a property name.
   */},{key:"_convertAttrNameToPropName",value:function _convertAttrNameToPropName(attrName){for(var prop in this.allProperties){if(this.allProperties[prop].attr===attrName){return prop}}// Convert the property name to kebab case
var propName=attrName.replace(/-([A-Za-z])/g,function(l){return l[1].toUpperCase()});return propName}},{key:"_convertSelectorsToArray",value:function _convertSelectorsToArray(selectors){if(selectors){if("string"===typeof selectors)return selectors.split(",");else if("array"===typeof selectors||"object"===babelHelpers.typeof(selectors))return selectors;else{this.warn("selectors should be provided as a string, array, or object; received: ".concat(babelHelpers.typeof(selectors),"."))}}return}},{key:"_parsePropertiesForCascade",value:function _parsePropertiesForCascade(mergedProperties){// Parse the properties to pull out attributes that cascade
for(var _this10=this,cascadingProperties={},_loop2=function _loop2(){var _Object$entries$_i=babelHelpers.slicedToArray(_Object$entries[_i],2),propName=_Object$entries$_i[0],config=_Object$entries$_i[1],cascadeTo=_this10._convertSelectorsToArray(config.cascade);// Iterate over each node in the cascade list for this property
if(cascadeTo)cascadeTo.map(function(nodeItem){var attr=_this10._prop2attr(propName);// Create an object with the node as the key and an array of attributes
// that are to be cascaded down to it
if(!cascadingProperties[nodeItem])cascadingProperties[nodeItem]=[attr];else cascadingProperties[nodeItem].push(attr)})},_i=0,_Object$entries=Object.entries(mergedProperties);_i<_Object$entries.length;_i++){_loop2()}return cascadingProperties}/**
   * Caching the attributes and properties data for efficiency
   */},{key:"create",value:function create(pfe){pfe._createCache();pfe._populateCache(pfe);pfe._validateProperties();window.customElements.define(pfe.tag,pfe)}},{key:"_createCache",value:function _createCache(){this._cache={properties:{},globalProperties:{},componentProperties:{},cascadingProperties:{},attr2prop:{},prop2attr:{}}}/**
   * Cache an object in a given cache namespace.  This overwrites anything
   * already in that namespace.
   */},{key:"_setCache",value:function _setCache(namespace,object){this._cache[namespace]=object}/**
   * Get a cached object by namespace, or get all cached objects.
   */},{key:"_getCache",value:function _getCache(namespace){return namespace?this._cache[namespace]:this._cache}/**
   * Populate initial values for properties cache.
   */},{key:"_populateCache",value:function _populateCache(pfe){// @TODO add a warning when a component property conflicts with a global property.
var mergedProperties=_objectSpread(_objectSpread({},pfe.properties),PFElement.properties);pfe._setCache("componentProperties",pfe.properties);pfe._setCache("globalProperties",PFElement.properties);pfe._setCache("properties",mergedProperties);// create mapping objects to go from prop name to attrname and back
var prop2attr={},attr2prop={};for(var propName in mergedProperties){var attrName=this._convertPropNameToAttrName(propName);prop2attr[propName]=attrName;attr2prop[attrName]=propName}pfe._setCache("attr2prop",attr2prop);pfe._setCache("prop2attr",prop2attr);var cascadingProperties=this._parsePropertiesForCascade(mergedProperties);if(Object.keys(cascadingProperties))pfe._setCache("cascadingProperties",cascadingProperties)}/**
   * allProperties returns an object containing PFElement's global properties
   * and the descendents' (such as PfeCard, etc) component properties.  The two
   * objects are merged together and in the case of a property name conflict,
   * PFElement's properties override the component's properties.
   */},{key:"allProperties",get:function get(){return this._getCache("properties")}/**
   * cascadingProperties returns an object containing PFElement's global properties
   * and the descendents' (such as PfeCard, etc) component properties.  The two
   * objects are merged together and in the case of a property name conflict,
   * PFElement's properties override the component's properties.
   */},{key:"cascadingProperties",get:function get(){return this._getCache("cascadingProperties")}}]);return PFElement}(/*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));autoReveal(PFElement.log);var _default2=PFElement;_exports.default=_default2});